\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{hyperref}
 

%opening
\title{CS167 Project 1: Shell}
\author{Zhang, Shu (szhang)}
 

\begin{document} 

\maketitle

\tableofcontents

\newpage

\section{General Overview}
My Shell program can simulate a large part of work that a read shell (like bash) can do, and runs in a stable status.
The main features my shell program provides are:
\begin{itemize}
 \item Supporting for a set of built-in commands.
 \item Being able to check for any direction and relatex syntax fails.
 \item Supporting use typing binaries without full paths.
 \item Won't crash for Ctrl-C, Ctrl-Z signals, but will be turned down when user typing Ctrl-D without any other chars.
 \item Zero memory leak.
\end{itemize}

\section{Code Brief Explanation}
The code could be analyzed from the main() function. First It will check the args, and print them out to STDOUT, but the args won't be used anymore.
Then, there are 4 parts of string buffers which are allocated with MAX\_LENGTH space. These string buffers are global so that all functions could visit
them easily. MAX\_LENGTH is set to 512 bytes.'commandline' is a buffer to store the whole user inputs in a line. 'command' is to store the parsed 
command part with arguments. 'input' is to store the path of the redirected input file path. For the output path, I used a linked list to store
all output files. However, only the last added file will be used for output redirection. The reason for this design is that I observed that even
user types in multiple redirected output file path, the bash will not crash, so this observation let me to use the linked list to store these outputs
all together without printing an syntax error. \textit{refresh\_buffers()} function is used to clean up all buffers by setting zeros to the heap spaces
or cleaning all nodes in the linked list. \textit{refresh\_buffers()} is called at the beginning of every loop in order to ensure that user inputs
won't interfere with other times' user inputs. As always appeared in pair,  \textit{free\_all\_resources()} is used to free all buffers before exiting
the program.

The major part of the program is the \textit{while(1)} loop in the main function. The workflow is like this: first it will register signal handlers
in case user input CTRL-C/CTRL-Z which might otherwise stop the program. Then, the shell reads user input from standard input, and first check if
there is 0 byte read, if yes, which means user only inputs CTRL-D, then the program will exit in response for this operation. Then, it will check 
whether the last char read is '\\n', which is 10 in ASCII code. If no, which means that the user input CTRL-D in the end of the string, the program will
ignore the user input this time.

If everything goes well, then the main loop goes to the core function of the program - \textit{process\_commandline()}. This function deals with
the user input and returns a result code. If the result code is not zero, then the program calls its \textit{error\_handler()} to print out 
error messges.All error codes are recorded in a global string array whose indeice are corresponding to the error codes. At the end of the loop,
the buffers are refreshed and starts another loop.

\section{Command Processing and Parsing}
This section describes the meat inside the \textit{process\_commandline()}. It first calls \textit{eliminate\_dup\_tab\_space()} which shrinks all
spaces or tabs into one, and eliminate all spaces and tabs in the start and end of the commandline input string. This pre-processing will make 
string parsing much easier. Then it calls a subfunction called \textit{parse\_commandline}. Inside this function, it calls split_to_parts()




\end{document}
